
1、回溯法是什么？
以深度优先的方式系统搜索问题解的算法称为回溯法。

2、什么类型的问题可以考虑用回溯？
若一个问题的解可以用一颗树（子集树、排列树）来表示，则可以考虑回溯。回溯可以输出问题的所有可行解，以及最优解。

3、如何用回溯来求解？
使用回溯求解问题的一般框架:
/**
 * 一般递归回溯的算法框架
 * 
 * @param num 辅助判断是否求得一个解
 * @param path 目前的搜索路径
 */
 * void fn(int num, int[] path){
 *      if(num==0){ //到达可行解
 *          print(path); //打印搜索到的结果
 *      }else{
 *          for(int i=f(num); i<=g(num); i++){ //遍历可选节点
 *              if(i满足约束条件){
 *              	fn(num-i, path+i);//选择可选结点，继续向深层搜索
 *              }
 *          }
 *      }
 * }
 
  /*
   * depth 判断是否达到一个可行解
   * sum 辅助确定当前的可行路径
   * path 保存当前的搜索路径
   *
  void fn(int depth, int sum, int[] path){
		if(depth > D){
			if(sum > max){
				max = sum;
			}
		}else{
			for(int i=0; i<n; i++){
				if(sum + i * weights[i] <= V){
					fn(depth+1, sum + i * weights[i], concat(path, k));
				}
			}
		}
  }
 
 /**
 * 在二叉树中回溯搜索的框架
 * 
 * @param node 当前搜索结点
 * @param num 辅助判断是否得到一个解
 * @param path 当前的搜索路径
 */
void backtrack(BiNode node, int num, int[] path){
	if(num == node.value || 其它){
		output(path + node);
	}else{
		if(node满足约束条件){ //递归搜索二叉树的左右子树
			if(node.left != null){
				backtrack(node.left, num-node.value, path+node);
			}
			if(node.right != null){
				backtrack(node.right, num-node.value, path+node);
			}
		}
	}
}

4、典型题
	# 全排列/幂集
		#全排列问题：
			每一层完成对一个元素的选择。第一层可以选n个元素的任意一个，第二层可以选剩余n-1个元素的任意一个。。。
		#幂集问题（组合问题）：
			每一层完成对一个元素的取舍。第一层对第一个元素进行取舍，第二层对第二个元素进行取舍。。。

	# 排列问题/组合问题（通常需要强制次序来防止重复）
		#青蛙跳台阶（跳n个台阶的跳法）：
			每一层选择当前跳的步长。第一层表示第一次可以跳1或2步，第二层表示第二次仍然可以跳1或2步。。。无深度限制
		#捞鱼（20条鱼放在20个桶里的不同放法）：
			每一层对应每个桶放多少条鱼。第一层选择第一个桶可以放（0,1,...,10)条鱼，第二层选择第二个桶可以放（0,1,...,10）条鱼，深度限制恰好为20。
		#骰子问题（5个骰子仍在地上，点数和为N的情况有多少种）
			每一层对应每个骰子的点数，第一层可以为1-6，第二层也是1-6，深度限制恰好是5。
		#硬币组合：
			思路1：每一层完成对一个元素个数的选择。第一层选取10分硬币的个数（可供选择的为0,1,...,n/10）,第二层选取5分硬币的个数（可选的为0,1,...,n/5）。
			思路2：每一层完成一个硬币的选择，约束条件是后选的硬币小于等于先选的硬币。第一层可选1,2,5,10，第一层的5对应第二层只能选1,2,5，不能选10。
	
	#背包问题：
		# 01背包：每一层选择是否装第i件物品。第一层选择是否装第一件物品；第二层选择是否装第二件物品。。。
		# 完全背包：每一层选择第i件物品的数目。第一次选择装第一件物品多少件；第二层选择装第二件物品多少件。。。
 